<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IDEA构建错误:Gradle:Cause:zip END header not found</title>
      <link href="posts/3790347158/"/>
      <url>posts/3790347158/</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1.问题复现"></a>1.问题复现</h1><p>在<a href="https://hyperskill.org/">hyperskill</a>学习Java时，之前导入项目都好好的。由于换了个账号（可能是切换了账号的原因），打开学习项目时，提示如下，运行按钮是灰的，并且提示：</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/20201018191932.png"></p><p>按提示点击按钮后，出现<code>build failed</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/20200917144049894.png" alt="没有截图，网上找的图"></p><h1 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h1><p>按照这篇教程：<a href="https://blog.csdn.net/bhfswrcn/article/details/107116657">idea使用gradle进行build时报错 Cause: zip END header not found</a>的方法，修改了配置</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/20201018193701.png" alt="修改配置"></p><p>重新构建，问题依然存在。</p><p>再次搜索了一下，按照这篇文章<a href="https://blog.csdn.net/haiquanquan123456/article/details/108642649">问题: gradle Cause: zip END header not found</a>试了一下，还是不行。</p><p>改变思路。</p><p>同时更改了<code>gradle-wrapper.properties</code>文件，配置如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">#把远程地址注释掉</span><br><span class="line">#distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-6.6.1-bin.zip</span></span><br><span class="line">#使用本地的gradle包</span><br><span class="line">distributionUrl=<span class="keyword">file</span>:<span class="comment">///D:/IdeaProjects/gradle-6.7-bin.zip</span></span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br></pre></td></tr></table></figure><p>找到<code>File-&gt;settings-&gt;Build,Execution,Deployment-&gt;Build Tools</code>下的<code>gradle</code>选项，设置为图中所示即可</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/20201018195116.png" alt="gradle设置"></p><p>重新build：</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/20201018194314.png" alt="重新build中"></p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/20201018195444.png" alt="build成功"></p><p>build成功后，右键运行一次后，即可开始写代码了。</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/20201018195702.png" alt="右键运行"></p><p>这里不再是灰色了！</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201018195813307.png" alt="ToolBar"></p><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h1><p>中间踩过的其他坑就不详细记述了，我太难了。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 教程 </category>
          
          <category> IDEA </category>
          
          <category> Gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> 编译错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="posts/3546711884/"/>
      <url>posts/3546711884/</url>
      
        <content type="html"><![CDATA[<h1 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</p><p>集合与数组的区别</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值，也可以存储对象。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><p>java.util.Collection类是所有<strong>单列集合</strong>的根接口；</p><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><h3 id="学习集合的目标"><a href="#学习集合的目标" class="headerlink" title="学习集合的目标"></a>学习集合的目标</h3><p>1.会使用集合存储数据</p><p>2.会遍历集合，把数据取出来</p><p>3.掌握每种集合的特性</p><h3 id="集合框架示意图"><a href="#集合框架示意图" class="headerlink" title="集合框架示意图"></a>集合框架示意图</h3><p>Java集合类主要是由两个根接口Collection和Map派生出来的。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic/imgs/集合框架图示.jpg"><p>Collection接口定义的是所有单列集合中共性的方法；所有单列集合都可以使用共性的方法；没有的带索引的方法。</p><ul><li>List接口：有序的集合（存储和取出元素顺序相同）；允许有重复的元素；有索引，可以使用普通的for循环遍历。</li><li>Set接口：不允许存储重复的元素；没有索引，不能使用普通的for循环遍历。TreeSet和HashSet是无序的集合（存储和取出元素顺序可能不同），LinkedHashSet是有序的集合。</li></ul><p>集合框架的学习方式：</p><p>学习顶层：学习顶层接口/抽象类中共性的方法，所有子类可以使用；</p><p>使用底层：顶层不是接口就是抽象类，无法创建对象使用，需要使用底层的子类创建对象使用。</p><h2 id="Collection集合常用功能-共性方法"><a href="#Collection集合常用功能-共性方法" class="headerlink" title="Collection集合常用功能 (共性方法)"></a>Collection集合常用功能 (共性方法)</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.shenzc.java.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用多态创建一个Collection对象</span></span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//打印ArrayList对象，重写了toString方法</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//isEmpty方法判断该集合是否为空，如果为空，则返回true；不为空，则返回false</span></span><br><span class="line">        System.out.println(list.isEmpty());</span><br><span class="line">        <span class="comment">//通过add方法向集合中添加元素，添加成功返回true，添加失败返回false。一般都是添加成功</span></span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;田七&quot;</span>);</span><br><span class="line">        <span class="comment">//添加完元素后再次判断集合是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());</span><br><span class="line">        <span class="comment">//用size方法得到集合中元素的个数</span></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//用remove方法删除集合中对应的元素，如果存在该元素则删除该元素返回true；否则返回false</span></span><br><span class="line">        list.remove(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(list.remove(<span class="string">&quot;赵四&quot;</span>));</span><br><span class="line">        <span class="comment">//用cotains方法判断集合中是否包含指定元素，包含则返回true，否则返回false</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;赵四&quot;</span>));</span><br><span class="line">        <span class="comment">//用toArray方法将集合转为对象数组</span></span><br><span class="line">        Object[] arr = list.toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用clear方法，清空集合</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><h3 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h3><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>boolean    hasNext()：Returns true if the iteration has more elements.<br>E    next()：Returns the next element in the iteration.</p><p>Iterator是一个接口，我们无法直接使用，需要使用Iterator的实现类来创建对象使用。但是获取实现类的方法比较特殊，我们可以利用Collection接口中的interator方法的返回值来创建一个Iterator接口的实现类对象。</p><h3 id="迭代器的使用步骤"><a href="#迭代器的使用步骤" class="headerlink" title="迭代器的使用步骤"></a>迭代器的使用步骤</h3><p>1、使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）；(Iterator也是有泛型的，集合是什么泛型，Iterator就是什么泛型)</p><p>2、使用Iterator接口中的方法hasNext判断集合中是否还有下一个元素；<br>3、使用Iterator接口中的方法next取出集合中的下一个元素</p><p>当没有下一个元素,执行next方法会报NoSuchElementException</p><h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.shenzc.java.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用多态创建一个Collection对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//向集合中添加一些元素，可以使用Collection的add方法</span></span><br><span class="line">        coll.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;田七&quot;</span>);</span><br><span class="line">        <span class="comment">//用Collection接口中的iterator()方法创建一个Iterator接口的实现类对象</span></span><br><span class="line">        <span class="comment">//迭代器的泛型与Collection的泛型一致</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = coll.iterator();</span><br><span class="line">        <span class="comment">//用Iterator接口中的hasNext方法判断集合中是否还有下一个元素，再用next方法获取下一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，<strong>不能对集合中的元素进行增删操作</strong>。也叫for-each循环</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>for(数据类型 变量名 : 数组名/集合名){</p><p>//其他操作</p><p>}</p><h3 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.shenzc.java.demo07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForEach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个整形数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//利用增强for循环遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr1)&#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//定义一个字符串数组</span></span><br><span class="line">        String[] arr2 = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//用增强for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String s : arr2)&#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic/imgs/image-20200713102012312.png"></p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@main/img/2020/10/17/image-20200816213305822.png" alt="泛型"></p><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储到集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>大家观察下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">String str = (String) it.next();</span><br><span class="line">System.out.println(str.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h2><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>弊端</p><p>集合只能存取特定类型的数据</p><h2 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h2><p>修饰符 class 类名&lt;代表泛型的变量&gt; {  }</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line"><span class="keyword">private</span> MVP mvp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义和使用含有泛型的方法"><a href="#定义和使用含有泛型的方法" class="headerlink" title="定义和使用含有泛型的方法"></a>定义和使用含有泛型的方法</h2><p>泛型定义在方法的修饰符和返回值之间</p><p>格式：</p><p>修饰符 &lt;泛型&gt; 返回值类型 方法名 （参数列表（使用泛型））{</p><p>}</p><p>含有泛型的方法，在调用方法时确定泛型的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(M m)</span></span>&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericMethod ge = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">        ge.method(<span class="number">4</span>);</span><br><span class="line">        ge.method(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义和使用含有泛型的接口"><a href="#定义和使用含有泛型的接口" class="headerlink" title="定义和使用含有泛型的接口"></a>定义和使用含有泛型的接口</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>格式</p><p><code>修饰符 interface 接口名&lt;泛型&gt;&#123;&#125;</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.定义类时确定泛型类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo02;</span><br><span class="line"><span class="comment">//在定义类时确定泛型的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.接口是什么泛型，实现类就是什么泛型，在实现类创建对象时确定泛型类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo02;</span><br><span class="line"><span class="comment">//接口是什么泛型，实现类就是什么泛型，在实现类创建对象时确定泛型类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericInterfaceImpl1 ge1 = <span class="keyword">new</span> GenericInterfaceImpl1();</span><br><span class="line">        ge1.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        GenericInterfaceImpl2&lt;String&gt; ge2 = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        ge2.add(<span class="string">&quot;CDD&quot;</span>);</span><br><span class="line">        GenericInterfaceImpl2&lt;Integer&gt; ge3 = <span class="keyword">new</span> GenericInterfaceImpl2&lt;&gt;();</span><br><span class="line">        ge3.add(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h2><p>当使用泛型类或者接口时，<strong>传递的数据</strong>中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wildcard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collection&lt;Integer&gt; coll2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        method(coll1);</span><br><span class="line">        method(coll2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedWildcard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        method1(list1);</span><br><span class="line">        method1(list2);</span><br><span class="line">        method1(list3);</span><br><span class="line">        method1(list4);</span><br><span class="line">        </span><br><span class="line">        method2(list1);</span><br><span class="line">        method2(list2);</span><br><span class="line">        method2(list3);</span><br><span class="line">        method2(list4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(Collection&lt;? extends Number&gt;coll)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt;coll)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic/imgs/20200817005015.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="posts/3150929911/"/>
      <url>posts/3150929911/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda的使用前提"><a href="#Lambda的使用前提" class="headerlink" title="Lambda的使用前提"></a>Lambda的使用前提</h1><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p><strong>The functional interface</strong> is an interface (not a class or enum) with a single abstract method (SAM type). Static and default methods are allowed here.</p><blockquote><p>函数式接口是一个只有单一抽象方法的接口（不是类或枚举类型）。静态方法和默认方法允许出现在函数式接口中。</p></blockquote><p>There is a special annotation <strong>@FunctionalInterface</strong> in <strong>The Java Class Library</strong>. It marks functional interfaces and indicates if the interface doesn’t  satisfy the requirements of a functional interface (compile-time error). The annotation is not mandatory but it’s recommended to mark functional interfaces.</p><blockquote><p>Java类库中指定了注解**@FunctionalInterface** 来标识函数式接口，使用此注解后不是函数式接口的接口将会出现编译期错误。此注解不是必须的，但建议用来标识函数式接口。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Func</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T val)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doNothingStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doNothingByDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个泛型函数式接口。只有一个实例方法<strong>apply</strong>。</p><p>The interface represents a function (in the math sense). The function has an instance method apply which takes a value of type T and returns a result of type R.</p><blockquote><p>这个接口代表一个函数（数学意义上的）。这个函数有一个实例方法，该方法接收一个泛型T的值，返回一个泛型R的值。</p></blockquote><p>The functional interface is another way to model functions using object-oriented programming instead of methods.</p><h2 id="实现函数式接口"><a href="#实现函数式接口" class="headerlink" title="实现函数式接口"></a>实现函数式接口</h2><p>We can’t create an instance of the functional interface <strong>Func&lt;T, R&gt;</strong> because it’s an interface. First, we should implement it and then  create an instance of the concrete class. The main thing is to implement the <strong>apply</strong> method to get a concrete behavior.</p><blockquote><p>我们不能直接实例化函数式接口，因为它是一个接口。首先，我们需要用一个实现类实现这个接口，然后创建一个实现类的实例。主要的事情就是实现apply方法得到具体行为。</p></blockquote><p>Like any interface, a functional interface can be implemented using regular inheritance or anonymous classes.</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>To implement a functional interface let’s create an anonymous class and  override the method apply. The overridden method calculates the square  of a given value.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Func&lt;Long,Long&gt; square = <span class="keyword">new</span> Func&lt;Long,Long&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">Long <span class="title">apply</span><span class="params">(Long va)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val * val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">long</span> val = square.apply(<span class="number">10L</span>);<span class="comment">//100L</span></span><br></pre></td></tr></table></figure><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Func&lt;Long,Long&gt; square = val -&gt; val * val;</span><br><span class="line"><span class="keyword">long</span> val =  square.apply(<span class="number">10L</span>);<span class="comment">//100L</span></span><br></pre></td></tr></table></figure><h2 id="Lambda表达式作为参数传给方法"><a href="#Lambda表达式作为参数传给方法" class="headerlink" title="Lambda表达式作为参数传给方法"></a>Lambda表达式作为参数传给方法</h2><p>It’s possible to pass a lambda expression to a method if the method takes an object of type a suitable functional interface.</p><p>Here is an example. The method <strong>acceptFunctionalInterface</strong> takes an object of the standard type <strong>Function&lt;Integer, Integer&gt;</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptFunctionalInterface</span><span class="params">(Function&lt;Integer, Integer&gt; f)</span> </span>&#123;</span><br><span class="line">   System.out.println(f.apply(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s pass some functions in the method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// it returns the next value</span></span><br><span class="line">Function&lt;Integer, Integer&gt; f = (x) -&gt; x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">acceptFunctionalInterface(f); <span class="comment">// it prints 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or even without a reference</span></span><br><span class="line">acceptFunctionalInterface(x -&gt; x + <span class="number">1</span>); <span class="comment">// the result is the same: 11</span></span><br></pre></td></tr></table></figure><p>Inside the method <strong>acceptFunctionalInterface</strong>, the given function will be invoked. In enterprise programming, it is often called <strong>the callback</strong>.</p><p>According to Wikipedia: “<em>a callback is a piece of executable code that is passed as an argument to other code, which is expected to call  back (execute) the argument at some convenient time.”</em></p><p>In other words, in Java, we can pass our functions (presented by objects) in a method/function as its arguments.</p><p><strong>Note</strong>. In functional programming, a function (including methods in Java) that accepts or returns another function is called a <strong>higher-order function</strong>. A lot of features such as <strong>function composition</strong>, <strong>currying</strong>, <strong>monads</strong>, and some others are based on this idea.</p><h2 id="Usage-of-closures"><a href="#Usage-of-closures" class="headerlink" title="Usage of closures"></a>Usage of closures</h2><p>In the body of a lambda expression, it’s  possible to capture values from a context where the lambda is defined.  This technique is called <strong>closure</strong>.</p><p>Let’s see an example.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String hello = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">Function&lt;String, String&gt; helloFunction = (name) -&gt; hello + name;</span><br><span class="line"></span><br><span class="line">System.out.println(helloFunction.apply(<span class="string">&quot;John&quot;</span>));</span><br><span class="line">System.out.println(helloFunction.apply(<span class="string">&quot;Anastasia&quot;</span>));</span><br></pre></td></tr></table></figure><p>The lambda expression captured the final variable <strong>hello</strong>.</p><p>The result of this code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, John</span><br><span class="line">Hello, Anastasia</span><br></pre></td></tr></table></figure><p>It’s possible only if a context variable has a keyword <strong>final</strong> or it’s <strong>effectively final</strong>, i.e. variable can’t be changed. Otherwise, an error happens.</p><p>Let’s consider the example with an effectively final variable.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> constant = <span class="number">100</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; adder = x -&gt; x + constant;</span><br><span class="line"></span><br><span class="line">System.out.println(adder.apply(<span class="number">200</span>));</span><br><span class="line">System.out.println(adder.apply(<span class="number">300</span>));</span><br></pre></td></tr></table></figure><p>The variable <strong>constant</strong> is effectively final and being captured by the lambda expression.</p><p><strong>Note.</strong> If we use anonymous classes instead of lambdas, we can do the same tricks.</p><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。<br> 无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一<br> 时，才可以使用Lambda。</li><li>使用Lambda必须具有上下文推断。<br> 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“函数式接口”。</p></blockquote><h1 id="函数式编程思想概述"><a href="#函数式编程思想概述" class="headerlink" title="函数式编程思想概述"></a>函数式编程思想概述</h1><p>在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过<br>分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以<br>什么形式做。<br>面向对象的思想:<br>做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.<br>函数式编程思想:<br>只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p><h1 id="冗余的Runnable代码"><a href="#冗余的Runnable代码" class="headerlink" title="冗余的Runnable代码"></a>冗余的Runnable代码</h1><h2 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h2><p>当需要启动一个线程去完成任务时，通常会通过 java.lang.Runnable 接口来定义任务内容，并使用<br>java.lang.Thread 类来启动该线程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类创建一个Runnable的实现类对象，作为参数传入Thread的构造器中，并重写Runnable的run方法设置线程任务，</span></span><br><span class="line">        <span class="comment">// 然后调用start方法，启动线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;重写了run方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个 Runnable 接口的匿名内部类对象来指定任务内<br>容，再将其交给一个线程来启动。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>对于 Runnable 的匿名内部类用法，可以分析出几点内容：</p><ul><li>Thread 类需要 Runnable 接口作为参数，其中的抽象 run 方法是用来指定线程任务内容的核心；</li><li>为了指定 run 的方法体，<strong>不得不</strong>需要 Runnable 接口的实现类；<br>  为了省去定义一个 RunnableImpl 实现类的麻烦，<strong>不得不</strong>使用匿名内部类；<br>  必须覆盖重写抽象 run 方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；<br>  而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h1 id="编程思想转换"><a href="#编程思想转换" class="headerlink" title="编程思想转换"></a>编程思想转换</h1><h1 id="改用更优的Lambda表达式"><a href="#改用更优的Lambda表达式" class="headerlink" title="改用更优的Lambda表达式"></a>改用更优的Lambda表达式</h1><p>借助Java 8的全新语法，上述 Runnable 接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*//使用匿名内部类创建一个Runnable的实现类对象，作为参数传入Thread的构造器中，并重写Runnable的run方法设置线程任务，</span></span><br><span class="line"><span class="comment">        // 然后调用start方法，启动线程</span></span><br><span class="line"><span class="comment">        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;重写了run方法&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).start();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda表达式写法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;重写了run方法&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们<br>启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。<br>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p><h1 id="匿名内部类回顾"><a href="#匿名内部类回顾" class="headerlink" title="匿名内部类回顾"></a>匿名内部类回顾</h1><h2 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h2><p>要启动一个线程，需要创建一个 Thread 类的对象并调用 start 方法。而为了指定线程执行的内容，需要调用<br>Thread 类的构造方法：<br>public Thread(Runnable target)<br>为了获取 Runnable 接口的实现对象，可以为该接口定义一个实现类 RunnableImpl，然后创建该实现类的对象作为 Thread 类的构造参数。</p><h2 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h2><p>这个 RunnableImpl 类只是为了实现 Runnable 接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的<br>语法即可省去该类的单独定义。</p><h2 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h2><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的<strong>语法——确实太复杂了</strong>！</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>仔细分析该代码中的语义， Runnable 接口只有一个 run 方法的定义：<br>public abstract void run();<br>即制定了一种做事情的方案（其实就是一个函数）：</p><ul><li>无参数：不需要任何条件即可执行该方案。</li><li>无返回值：该方案不产生任何结果。</li><li>代码块（方法体）：该方案的具体执行步骤。</li></ul><p>同样的语义体现在 Lambda 语法中，要更加简单：</p><p><code>() -&gt; &#123; System.out.println(&quot;重写了run方法&quot;);&#125;</code></p><ul><li>前面的一对小括号即 run 方法的参数（无），代表不需要任何条件；</li><li>中间的一个箭头代表将前面的参数传递给后面的代码；</li><li>后面的输出语句即业务逻辑代码。</li></ul><h1 id="Lambda语句标准格式"><a href="#Lambda语句标准格式" class="headerlink" title="Lambda语句标准格式"></a>Lambda语句标准格式</h1><p>Lambda省去面向对象的条条框框，格式由3个部分组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><p>Lambda表达式的标准格式为：</p><p><code>(参数类型 参数名称) ‐&gt; &#123; 代码语句 &#125;</code></p><p>格式说明：<br>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。<br>-&gt; 是新引入的语法格式，代表指向动作。<br>大括号内的语法与传统方法体要求基本一致</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><h3 id="示例1：无参无返回"><a href="#示例1：无参无返回" class="headerlink" title="示例1：无参无返回"></a>示例1：无参无返回</h3><p>给定一个厨子 Cook 接口，内含唯一的抽象方法 makeFood ，且无参数、无返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的代码中，请使用Lambda的标准格式调用 invokeCook 方法，打印输出“吃饭啦！”字样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeCook</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">cook.makeFood();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeCook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类实现</span></span><br><span class="line">        invokeCook(<span class="keyword">new</span> Cook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        invokeCook(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200912012644274.png"></p><h3 id="示例2：有参有返回"><a href="#示例2：有参有返回" class="headerlink" title="示例2：有参有返回"></a>示例2：有参有返回</h3><p>给定一个计算器 Calculator 接口，内含抽象方法 calc 可以将两个int数字相加得到和值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的代码中，请使用Lambda的标准格式调用 invokeCalc 方法，完成120和130的相加计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08InvokeCalc</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span></span><br><span class="line">&#125; p</span><br><span class="line"><span class="function">rivate <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator calculator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = calculator.calc(a, b);</span><br><span class="line">System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">120</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">130</span>;</span><br><span class="line">        <span class="comment">/*//匿名内部类方式</span></span><br><span class="line"><span class="comment">        invokeCalc(a, b, new Calculator() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int calc(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">                return a + b;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda方式</span></span><br><span class="line">        invokeCalc(a, b, (<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = calculator.calc(a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h1><h2 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h2><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内有且仅有一个参，则小括号可以省略；</li><li>如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号（三个要一起省略）。</li></ol><h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeCook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类实现</span></span><br><span class="line">        invokeCook(<span class="keyword">new</span> Cook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        invokeCook(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda省略格式</span></span><br><span class="line">        invokeCook(() -&gt; System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200912013249950.png"></p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.buercheng.java.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">120</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">130</span>;</span><br><span class="line">        <span class="comment">/*//匿名内部类方式</span></span><br><span class="line"><span class="comment">        invokeCalc(a, b, new Calculator() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int calc(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">                return a + b;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda方式</span></span><br><span class="line">        invokeCalc(a, b, (<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda省略格式</span></span><br><span class="line">        invokeCalc(<span class="number">120</span>,<span class="number">130</span>,(x,y) -&gt; x + y);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = calculator.calc(a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200912013439324.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vercel部署hexo</title>
      <link href="posts/776259585/"/>
      <url>posts/776259585/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分：本地部署"><a href="#第一部分：本地部署" class="headerlink" title="第一部分：本地部署"></a>第一部分：本地部署</h1><p>这一步主要参考了<a href="https://zhuanlan.zhihu.com/p/44213627">知乎这篇文章</a>和<a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></p><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><p>官方地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>淘宝镜像地址：<a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></p><h2 id="2-安装-Node-js"><a href="#2-安装-Node-js" class="headerlink" title="2.安装 Node.js"></a>2.安装 Node.js</h2><p>官方地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>淘宝镜像地址：<a href="https://npm.taobao.org/mirrors/node">https://npm.taobao.org/mirrors/node</a></p><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>至此就全部安装完了。</p><p>接下来初始化一下hexo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><p>这个myblog可以自己取什么名字都行，然后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myblog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li></ul><p>继续执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。使用ctrl+c可以把服务关掉。</p><p>本地安装就基本结束了。</p><h1 id="第二部分：同步静态网页到github"><a href="#第二部分：同步静态网页到github" class="headerlink" title="第二部分：同步静态网页到github"></a>第二部分：同步静态网页到github</h1><blockquote><p>注意：这里同步的是利用<code>hexo g</code>生成的静态网页文件</p></blockquote><h2 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h2><p>github主页右上角，<code>New repository</code>，如果不需要使用githubpage部署的话，名字随便取，如果要使用githubpage部署的话，必须保证仓库名为<code>github用户名.github.io</code>。保证仓库为public，创建完成</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013183848372.png" alt="image-20201013183848372"></p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013184310009.png" alt="image-20201013184310009"></p><h2 id="2-生成SSH添加到Github"><a href="#2-生成SSH添加到Github" class="headerlink" title="2.生成SSH添加到Github"></a>2.生成SSH添加到Github</h2><p>回到你的git bash中，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013184640451.png" alt="image-20201013184640451"></p><p>而后在GitHub的settings中，找到SSH keys的设置选项，点击<code>New SSH key</code> 把你的<code>id_rsa.pub</code>里面的信息复制进去。</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013184817623.png" alt="image-20201013184817623"></p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013184921881.png" alt="image-20201013184921881"></p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013185039166.png" alt="image-20201013185039166"></p><p>在gitbash中，查看是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013185216648.png" alt="image-20201013185216648"></p><blockquote><p>不成功可能有很多原因，可以百度解决</p></blockquote><h1 id="第三部分：部署博客"><a href="#第三部分：部署博客" class="headerlink" title="第三部分：部署博客"></a>第三部分：部署博客</h1><h2 id="1-将博客部署到github"><a href="#1-将博客部署到github" class="headerlink" title="1.将博客部署到github"></a>1.将博客部署到github</h2><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为 YourgithubName就是你的GitHub账户。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/YourgithubName/YourgithubName.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment">#分支名有可能默认为main</span></span><br></pre></td></tr></table></figure><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。在<code>myblog</code>目录下（以上命令也全是在该目录下，下同）打开gitbash，输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #删除public目录</span><br><span class="line">hexo generate #生成静态网页文件</span><br><span class="line">hexo deploy #部署到github</span><br></pre></td></tr></table></figure><p>注意deploy时可能要你输入username和password。</p><p>得到类似的信息说明部署成功：</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013190148372.png" alt="image-20201013190148372"></p><p>如果是用githubpage部署的，这时候访问<code>http://yourname.github.io</code>就能打开博客了。</p><h2 id="2-将博客部署到Vercel"><a href="#2-将博客部署到Vercel" class="headerlink" title="2.将博客部署到Vercel"></a>2.将博客部署到Vercel</h2><p>众所周知，GithubPage的访问速度很慢，但是有了Vercel（Zeit）咱就不用担心了。</p><p>进入<a href="https://vercel.com/">vercel</a>，使用邮箱注册或者使用github登录。</p><p>进入dashboard，选择<code>Import Project</code></p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013190748764.png" alt="image-20201013190748764"></p><p>vercel提供了两种方式导入项目，这里我们选择第一种，直接导入仓库的静态网页文件。第二种是直接导入模板，在vercel服务器上生成网页，大概就是生成速度比较慢吧，但是部署简单。（我也没发现两者太大的区别）。</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013191045347.png" alt="image-20201013191045347"></p><p>接下来，填入你之前生成的仓库地址，可以在github主页找到。形如<code>https://github.com/zerohk/hexo_blog.git</code></p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013191250052.png" alt="image-20201013191250052"></p><p>接下来选择root路径，一般就是仓库名。</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013191720346.png" alt="image-20201013191720346"></p><p>projectname就默认，框架就选择other，然后deploy部署</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013192006781.png" alt="image-20201013192006781"></p><p>部署成功就会显示礼花场景，然后会分配一个二级域名，打开就可以访问博客了。</p><h1 id="第四部分：添加自定义域名"><a href="#第四部分：添加自定义域名" class="headerlink" title="第四部分：添加自定义域名"></a>第四部分：添加自定义域名</h1><p>回到dashboard，点击项目</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013192319324.png" alt="image-20201013192319324"></p><p>view domains</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013192427234.png" alt="image-20201013192427234"></p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013192526447.png" alt="image-20201013192526447"></p><p>去域名商那里添加DNS记录即可。</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013192755615.png" alt="image-20201013192755615"></p><h1 id="第五部分：发表文章、更改主题"><a href="#第五部分：发表文章、更改主题" class="headerlink" title="第五部分：发表文章、更改主题"></a>第五部分：发表文章、更改主题</h1><h2 id="1-发布文章更新站点"><a href="#1-发布文章更新站点" class="headerlink" title="1.发布文章更新站点"></a>1.发布文章更新站点</h2><p>参考<a href="https://blog.buercheng.space/posts/1820155650">发布文章指南</a>。都是在本地博客根目录，打开shell或gitbash执行这些命令。</p><p>执行<code>hexo d</code>到github后，vercel会自动更新部署。基本上，上传到github后，vercel就自动更新网站了。</p><p><img src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20201013193433227.png" alt="image-20201013193433227"></p><h2 id="2-更改主题"><a href="#2-更改主题" class="headerlink" title="2.更改主题"></a>2.更改主题</h2><p>可以上<a href="https://hexo.io/">hexo官网</a>找到喜欢的主题，按照文档更改</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> vercel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="posts/2215875518/"/>
      <url>posts/2215875518/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>1.多表之间的关系</p><p>2.数据库设计的范式</p><h1 id="多表之间的关系"><a href="#多表之间的关系" class="headerlink" title="多表之间的关系"></a>多表之间的关系</h1><h2 id="1、一对一的关系（了解）"><a href="#1、一对一的关系（了解）" class="headerlink" title="1、一对一的关系（了解）"></a>1、一对一的关系（了解）</h2><p>比如，人和身份证。一个人对应一个身份证，一个身份证只能被一个人使用</p><h2 id="2、一对多（多对一）的关系"><a href="#2、一对多（多对一）的关系" class="headerlink" title="2、一对多（多对一）的关系"></a>2、一对多（多对一）的关系</h2><p>比如，员工和部门。一个员工只能在一个部门，一个部门可以有多个员工。员工相对部门是多对一的关系，部门相对员工是一对多的关系。</p><h2 id="3、多对多的关系"><a href="#3、多对多的关系" class="headerlink" title="3、多对多的关系"></a>3、多对多的关系</h2><p>比如，学生和课程。一个学生可以选择多个课程，一个课程可以被多个学生选择。</p><h1 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h1><h2 id="一对一的关系实现"><a href="#一对一的关系实现" class="headerlink" title="一对一的关系实现"></a>一对一的关系实现</h2><p>一对一关系的实现，可以在任意一方添加<strong>唯一</strong>的外键来指向另一方的主键。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200926225458347.png" alt="image-20200926225458347"></p><h2 id="一对多的关系实现"><a href="#一对多的关系实现" class="headerlink" title="一对多的关系实现"></a>一对多的关系实现</h2><p>一对多关系的实现，在多（n）的一方，建立外键，来指向一的一方的主键。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200926230326010.png" alt="image-20200926230326010"></p><h2 id="多对多的关系实现"><a href="#多对多的关系实现" class="headerlink" title="多对多的关系实现"></a>多对多的关系实现</h2><p>多对多关系的实现需要借助第三张表作为中间表，中间表至少要有两个字段，这两个字段分别作为第三张表的外键，指向多对多关系中额两张表的主键。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200926231202323.png" alt="image-20200926231202323"></p><h1 id="多表关系案例"><a href="#多表关系案例" class="headerlink" title="多表关系案例"></a>多表关系案例</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>三个表：旅游线路分类，旅游线路，游客。在数据库中实现。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200926232543530.png" alt="image-20200926232543530"></p><h2 id="表之间的关系"><a href="#表之间的关系" class="headerlink" title="表之间的关系"></a>表之间的关系</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200926233322624.png" alt="image-20200926233322624"></p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">-- 建立分类表</span><br><span class="line">-- cid 线路分类主键，自动增长</span><br><span class="line">-- cname 分类名称非空 唯一，字符串100</span><br><span class="line">CREATE TABLE tab_category(</span><br><span class="line">cid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">cname VARCHAR(100) NOT NULL UNIQUE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建线路表 tab_route</span><br><span class="line">&#x2F;*</span><br><span class="line">rid:旅游线路主键，自动增长</span><br><span class="line">rname：旅游线路名称，唯一，非空，字符串100</span><br><span class="line">price：价格</span><br><span class="line">rdate：上架时间，日期类型</span><br><span class="line">cid：外键，所属线路分类</span><br><span class="line">*&#x2F;</span><br><span class="line">CREATE TABLE tab_route(</span><br><span class="line">rid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">rname VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">price DOUBLE,</span><br><span class="line">rdate DATE,</span><br><span class="line">cid INT,</span><br><span class="line">FOREIGN KEY (cid) REFERENCES tab_category(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建用户表</span><br><span class="line">&#x2F;*</span><br><span class="line">uid 用户主键，自增长</span><br><span class="line">username 用户名长度 100，唯一，非空</span><br><span class="line">password 密码长度 30，非空</span><br><span class="line">name 真实姓名长度 100</span><br><span class="line">birthday 生日</span><br><span class="line">sex 性别，定长字符串 1</span><br><span class="line">telephone 手机号，字符串 11</span><br><span class="line">email 邮箱，字符串长度 100</span><br><span class="line">*&#x2F;</span><br><span class="line">CREATE TABLE tab_user(</span><br><span class="line">uid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">username VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">PASSWORD VARCHAR(30) NOT NULL,</span><br><span class="line">NAME VARCHAR(100),</span><br><span class="line">birthday DATE,</span><br><span class="line">sex VARCHAR(1) DEFAULT &#39;男&#39;,-- default 指定默认值</span><br><span class="line">telephone VARCHAR(11),</span><br><span class="line">email VARCHAR(100)</span><br><span class="line">);</span><br><span class="line">-- 添加数据  insert into 表名[(列名,...)] values(值),(值),...;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_category (cname) VALUES (&#39;周边游&#39;), (&#39;出境游&#39;), (&#39;国内游&#39;), (&#39;港澳游&#39;);</span><br><span class="line">SELECT * FROM tab_category;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_route VALUES</span><br><span class="line">(NULL, &#39;【厦门+鼓浪屿+南普陀寺+曾厝垵 高铁 3 天 惠贵团】尝味友鸭面线 住 1 晚鼓浪屿&#39;, 1499,&#39;2018-01-27&#39;, 1),</span><br><span class="line">(NULL, &#39;【浪漫桂林 阳朔西街高铁 3 天纯玩 高级团】城徽象鼻山 兴坪漓江 西山公园&#39;, 699, &#39;2018-02-22&#39;, 3),</span><br><span class="line">(NULL, &#39;【爆款￥1699 秒杀】泰国 曼谷 芭堤雅 金沙岛 杜拉拉水上市场 双飞六天【含送签费 泰风情 广州往返 特价团】&#39;, 1699, &#39;2018-01-27&#39;, 2),</span><br><span class="line">(NULL, &#39;【经典•狮航 ￥2399 秒杀】巴厘岛双飞五天 抵玩【广州往返 特价团】&#39;, 2399, &#39;2017-12-23&#39;,2),</span><br><span class="line">(NULL, &#39;香港迪士尼乐园自由行 2 天【永东跨境巴士广东至迪士尼去程交通+迪士尼一日门票+香港如心海景酒店暨会议中心标准房 1 晚住宿】&#39;, 799, &#39;2018-04-10&#39;, 4);</span><br><span class="line">SELECT * FROM tab_route;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_user VALUES</span><br><span class="line">(NULL, &#39;cz110&#39;, 123456, &#39;老王&#39;, &#39;1977-07-07&#39;, &#39;男&#39;, &#39;13888888888&#39;, &#39;66666@qq.com&#39;),</span><br><span class="line">(NULL, &#39;cz119&#39;, 654321, &#39;小王&#39;, &#39;1999-09-09&#39;, &#39;男&#39;, &#39;13999999999&#39;, &#39;99999@qq.com&#39;);</span><br><span class="line">SELECT * FROM tab_user;</span><br><span class="line"></span><br><span class="line">-- 创建线路表和用户表的中间表 -- 收藏表</span><br><span class="line">&#x2F;*</span><br><span class="line">创建收藏表 tab_favorite</span><br><span class="line">rid 旅游线路 id，外键</span><br><span class="line">date 收藏时间</span><br><span class="line">uid 用户 id，外键</span><br><span class="line">rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次</span><br><span class="line">*&#x2F;</span><br><span class="line">CREATE TABLE tab_favorite(</span><br><span class="line">rid INT,</span><br><span class="line">DATE DATE,</span><br><span class="line">uid INT,</span><br><span class="line">-- 创建联合主键</span><br><span class="line">PRIMARY KEY(rid,uid),</span><br><span class="line">FOREIGN KEY(rid) REFERENCES tab_route(rid),-- 添加外键的简化形式</span><br><span class="line">FOREIGN KEY(uid) REFERENCES tab_user(uid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加收藏数据</span><br><span class="line">INSERT INTO tab_favorite VALUES</span><br><span class="line">(1, &#39;2018-01-01&#39;, 1), -- 老王选择厦门</span><br><span class="line">(2, &#39;2018-02-11&#39;, 1), -- 老王选择桂林</span><br><span class="line">(3, &#39;2018-03-21&#39;, 1), -- 老王选择泰国</span><br><span class="line">(2, &#39;2018-04-21&#39;, 2), -- 小王选择桂林</span><br><span class="line">(3, &#39;2018-05-08&#39;, 2), -- 小王选择泰国</span><br><span class="line">(5, &#39;2018-06-02&#39;, 2); -- 小王选择迪士尼</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_favorite;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>设计数据库时需要遵循的规则。要满足后边的范式，必须遵循前面的范式。</p><blockquote><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。<br>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p></blockquote><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>满足前三大范式，数据库设计基本就可以了。</p><p><strong>1、第一范式（1NF）：</strong>数据库表的每一列都是不可分割的原子数据项。</p><p><strong>2、第二范式（2NF）：</strong>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上<strong>消除</strong>非主属性对主码的<strong>部分函数依赖</strong>）。</p><p><strong>3、第三范式（3NF）：</strong>在2NF基础上，任何非主<a href="https://baike.baidu.com/item/%E5%B1%9E%E6%80%A7">属性</a>不依赖于其它非主属性（在2NF基础上<strong>消除传递依赖</strong>）。</p><h2 id="三大范式详解"><a href="#三大范式详解" class="headerlink" title="三大范式详解"></a>三大范式详解</h2><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929081704933.png" alt="image-20200929081704933"></p><p>在如图示的学生信息表中，系这一列还可以分为系名和系主任，因此这个表不是每一项都是不可分割的原子项。（不满足第一范式）。</p><p>要让这个表满足第一范式，可以这样操作，直接将系名和系主任作为单独的列：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929082005067.png" alt="image-20200929082005067"></p><p>不满足第一范式，在数据库中连表都创建不出。</p><p>满足第一范式存在的问题：</p><p>1.存在非常严重的数据冗余（重复）：姓名，系名，系主任。</p><p>2.数据添加存在问题：比如添加新开设的系和系主任时，数据不合法。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929082329457.png" alt="image-20200929082329457"></p><p>3.删除数据存在问题：比如张无忌毕业了，删除数据，系名，系主任都会被删除。</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>几个概念：</p><p>1.函数依赖：A–&gt;B:如果通过A<strong>属性或属性组</strong>的值，可以确定<strong>唯一</strong>B属性的值，则说B函数依赖A</p><p>例如：学号–&gt;姓名，&lt;学号，课程名称&gt;–&gt;分数</p><p>2.完全函数依赖：A–&gt;B,如果A是一个<strong>属性组</strong>，B属性的确定需要依赖于A属性组中<strong>所有属性</strong>的值，则称B完全依赖于A。</p><p>例如：&lt;学号，课程名称&gt;–&gt;分数</p><p>3.部分函数依赖：A–&gt;B，如果A是一个<strong>属性组</strong>，B属性的确定只需要依赖于A属性组中<strong>部分属性</strong>的值，则称B部分依赖于A。</p><p>例如：&lt;学号，课程名称&gt;–&gt;姓名（只需学号就能确定姓名）</p><p>4。传递函数依赖：A–&gt;B，B–&gt;C：如果通过A<strong>属性或属性组</strong>的值，可以确定唯一B属性或属性组的值，同时，通过B属性或属性组的值，可以唯一确定C属性或属性组的值，则称C传递函数依赖于A</p><p>例如：学号–&gt;系名，系名–&gt;系主任</p><p>5.码：如果在一张表中，一个属性或属性组，被其他所有属性完全依赖，则称该属性或属性组为这个表的码。</p><p>例如：该表的码为：（学号，课程名称）</p><p>主属性：码属性组中的所有属性</p><p>非主属性：除码属性组的属性之外的属性。</p><p>满足第二范式的要求就是在第一范式基础上消除部分函数依赖。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929092617983.png" alt="image-20200929092617983"></p><p>（学号，课程名称）作为码的话，姓名，系名，系主任都是部分依赖于码（姓名，系名完全依赖于学号，系主任传递依赖于学号），只有分数完全依赖于（学号，课程名称）。所以，可以把表进行拆分，以满足第二范式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929092915704.png" alt="image-20200929092915704"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929092951398.png" alt="image-20200929092951398"></p><p>满足第二范式存在的问题：</p><p>2.数据添加存在问题：添加新开设的系和系主任时，数据不合法<br>3.数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>满足第三范式需要在遵循第二范式的基础上消除传递依赖。</p><p>从第二范式的学生表来看，系主任传递依赖于学号，所以可以继续对表进行拆分。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929093230866.png" alt="image-20200929093230866"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929093248278.png" alt="image-20200929093248278"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929093308020.png" alt="image-20200929093308020"></p><p>以上几个问题都不存在了。</p><h1 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h1><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码 数据库名称 &gt; 保存路径\文件名.sql</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929094414760.png" alt="image-20200929094414760"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929094616356.png" alt="image-20200929094616356"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929094639576.png" alt="image-20200929094639576"></p><h3 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h3><p>1.登录数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u用户名 -p;</span><br></pre></td></tr></table></figure><p>2.创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名;</span><br></pre></td></tr></table></figure><p>3.使用数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名</span><br></pre></td></tr></table></figure><p>4.执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source 保存路径\文件名.sql</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929095755781.png" alt="image-20200929095755781"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929095815725.png" alt="image-20200929095815725"></p><h2 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h2><h3 id="备份-1"><a href="#备份-1" class="headerlink" title="备份"></a>备份</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929100430802.png" alt="image-20200929100430802"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929100454200.png" alt="image-20200929100454200"></p><h2 id="还原-1"><a href="#还原-1" class="headerlink" title="还原"></a>还原</h2><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929100558175.png" alt="image-20200929100558175"></p><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">列名列表</span><br><span class="line">from </span><br><span class="line">表名列表</span><br><span class="line">where...</span><br></pre></td></tr></table></figure><p>创建两个表：部门表，员工表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-- 创建部门表</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO dept(NAME) VALUES(&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);</span><br><span class="line"></span><br><span class="line">-- 创建员工表</span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(10),</span><br><span class="line">gender CHAR(1),</span><br><span class="line">salary DOUBLE,</span><br><span class="line">join_date DATE,</span><br><span class="line">dept_id INT,</span><br><span class="line">FOREIGN KEY (dept_id) REFERENCES dept(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from dept,emp;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929103312328.png" alt="image-20200929103312328"></p><p>笛卡尔积：简单的说就是两个集合相乘的结果。</p><p>要完成多表查询需要消除无用查询。</p><h1 id="多表查询的分类"><a href="#多表查询的分类" class="headerlink" title="多表查询的分类"></a>多表查询的分类</h1><h2 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h2><p>组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdn.net/20171209135846780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><h3 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h3><p>使用where条件来消除无用查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询所有员工信息和对应的部门信息</span><br><span class="line">SELECT * FROM emp,dept WHERE emp.&#96;dept_id&#96; &#x3D; dept.&#96;id&#96;; -- 注意，不是单引号，是大键盘1旁边的符号 ，加或不加都一样</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929104250106.png" alt="image-20200929104250106"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工表的名称，性别，部门表的名称</span><br><span class="line">select emp.name,emp.gender,dept.name from emp,dept where emp.dept_id &#x3D; dept.id;</span><br></pre></td></tr></table></figure><p>更常用的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">t1.name,</span><br><span class="line">t1.gender,</span><br><span class="line">t2.name</span><br><span class="line">from</span><br><span class="line">emp t1, -- 起别名</span><br><span class="line">dept t2 </span><br><span class="line">where</span><br><span class="line">t1.dept_id &#x3D; t2.id;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929151319902.png" alt="image-20200929151319902"></p><h3 id="显式内连接"><a href="#显式内连接" class="headerlink" title="显式内连接"></a>显式内连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表名1 [inner] join 表名2 on 条件;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询所有员工信息和对应的部门信息</span><br><span class="line">select * from emp [inner] join dept on emp.&#96;dept_id&#96; &#x3D; dept.&#96;id&#96;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929152049136.png" alt="image-20200929152049136"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929152113819.png" alt="image-20200929152113819"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>从哪些表中查询数据；查询的条件是什么；查询哪些字段。</p><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><p>与显式内连接类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表1名 left [outer] join 表2名 on 条件;</span><br></pre></td></tr></table></figure><p>假设新增了一个员工，但是未指定部门（即dept_id为NULL）</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@pics/img/image-20200929210431997.png" alt="image-20200929210431997"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询所有员工信息，如果员工有部门，则显示部门名称，没有部门则不显示</span><br><span class="line">select</span><br><span class="line">t1.*,t2.name</span><br><span class="line">from</span><br><span class="line">emp t1,</span><br><span class="line">dept t2</span><br><span class="line">where</span><br><span class="line">t1.dept_id &#x3D; t2.id;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/image-20200929210906698.png" alt="image-20200929210906698"></p><p>会发现上述查询并不显示部门为NULL的员工信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">t1.*,t2.name</span><br><span class="line">from</span><br><span class="line">emp t1</span><br><span class="line">left join</span><br><span class="line">dept t2</span><br><span class="line">on</span><br><span class="line">t1.dept_id &#x3D; t2.id;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/image-20200929211218700.png" alt="image-20200929211218700"></p><p>左(外)连接，左表(相对)的记录将会全部表示出来，而右表(相对)只会显示符合搜索条件（两表交集）的记录。右表记录不足的地方均为NULL。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/20171209142610819.png" alt="img"></p><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件（两表交集 ）的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/20171209144056668.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 右外连接</span><br><span class="line">SELECT </span><br><span class="line">t1.*,t2.&#96;name&#96;</span><br><span class="line">FROM</span><br><span class="line">emp t1</span><br><span class="line">RIGHT JOIN</span><br><span class="line">dept t2</span><br><span class="line">ON</span><br><span class="line">t1.&#96;dept_id&#96; &#x3D; t2.&#96;id&#96;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/image-20200929213603281.png" alt="image-20200929213603281"></p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>查询中嵌套查询，称嵌套查询为子查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查询工资最高的员工信息</span><br><span class="line">-- 1.查询工资最高是多少？9000</span><br><span class="line">select max(salary) from emp;</span><br><span class="line">-- 2.查询员工信息，并且工资等于9000</span><br><span class="line">select * from emp where emp.salary &#x3D; 9000;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/image-20200929214500246.png" alt="image-20200929214500246"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 一步到位，不分开查询</span><br><span class="line">select * from emp where emp.salary &#x3D; (select max(salary) from emp);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/image-20200929214730544.png" alt="image-20200929214730544"></p><h3 id="子查询的不同情况"><a href="#子查询的不同情况" class="headerlink" title="子查询的不同情况"></a>子查询的不同情况</h3><p>1.子查询的结果是单行单列的：</p><p>​    子查询可以作为条件，使用运算符（&gt;、＞＝、&lt;、＜=、=）去判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询小于平均工资的员工信息</span><br><span class="line">select * from emp where salary &lt; (select avg(salary) from emp);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/image-20200929221835583.png" alt="image-20200929221835583"></p><p>2.子查询的结果是多行单列的：</p><p>​    子查询可以作为条件，使用运算符in来判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 查询财务部和市场部所有员工的信息</span><br><span class="line">select id from dept where name &#x3D; &#39;财务部&#39; or name &#x3D; &#39;市场部&#39;;</span><br><span class="line">select * from emp where dept_id &#x3D; 2 or dept_id &#x3D; 3;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/image-20200929222714568.png" alt="image-20200929222714568"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 子查询</span><br><span class="line">select * from emp where dept_id in (select id from dept where name in(&#39;市场部&#39;,&#39;财务部&#39;));</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/image-20200929223223480.png" alt="image-20200929223223480"></p><p>3.子查询的结果是多行多列的：</p><p>子查询可以作为一张虚拟表来进行表的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询入职日期是2011-11-11之后的员工信息和部门信息</span><br><span class="line">-- 日期可以直接使用逻辑运算符来判断大小</span><br><span class="line">select * from emp where emp.join_date &gt; &#39;2011-11-11&#39;;-- 作为虚拟表</span><br><span class="line">select * from dept t1,(select * from emp where emp.join_date &gt; &#39;2011-11-11&#39;) t2 where t1.id &#x3D; t2.dept_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/image-20200929224039502.png" alt="image-20200929224039502"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 笔记 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础知识</title>
      <link href="posts/2640443603/"/>
      <url>posts/2640443603/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库的安装、卸载"><a href="#数据库的安装、卸载" class="headerlink" title="数据库的安装、卸载"></a>数据库的安装、卸载</h1><h1 id="数据库的启动与登录"><a href="#数据库的启动与登录" class="headerlink" title="数据库的启动与登录"></a>数据库的启动与登录</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="通过服务启动MySQL服务。"><a href="#通过服务启动MySQL服务。" class="headerlink" title="通过服务启动MySQL服务。"></a>通过服务启动MySQL服务。</h3><p>1、可以通过右键计算机—&gt;管理—&gt;服务和应用程序—&gt;服务，找到MySQL服务启动。</p><p>2、可以通过win+R，输入services.msc快捷进入服务页面。</p><p>可以将MySQL服务设置为自动启动，就不再需要手动开启了。</p><h3 id="通过控制台启动MySQL服务"><a href="#通过控制台启动MySQL服务" class="headerlink" title="通过控制台启动MySQL服务"></a>通过控制台启动MySQL服务</h3><p>以管理员模式打开控制台。</p><p><code>net start mysql</code>:启动MySQL服务。</p><p><code>net stop mysql</code>:关闭MySQL服务。</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="本地数据库登录"><a href="#本地数据库登录" class="headerlink" title="本地数据库登录"></a>本地数据库登录</h3><p>1、<code>mysql -u用户名 -p密码</code></p><p>2、<code>mysql -u用户名 -p</code>:回车后要求输入密码</p><h3 id="远程数据库登录"><a href="#远程数据库登录" class="headerlink" title="远程数据库登录"></a>远程数据库登录</h3><p>1、<code>mysql -h远程数据库地址 -u用户名 -p密码 </code></p><p>2、<code>mysql -h远程数据库地址 -u用户名 -p</code></p><p>3、<code>mysql --host=远程数据库地址 --user=用户名 --password=密码</code></p><p>4、<code>mysql --host=远程数据库地址 --user=用户名 --password</code></p><h1 id="数据库的目录结构"><a href="#数据库的目录结构" class="headerlink" title="数据库的目录结构"></a>数据库的目录结构</h1><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200921211212387.png" alt="image-20200921211212387"></p><p><code>bin</code>：执行文件</p><p><code>data</code>：用于放置一些日志文件以及数据库</p><p><code>include</code>：用于放置一些头文件</p><p><code>lib</code>:用于放置一系列库文件</p><p><code>share</code>:用于存放字符集、语言等信息</p><p><code>my.ini</code>:配置文件</p><h1 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Structured Query Language：结构化查询语言<br>    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。</p><h2 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h2><ol><li><p>SQL 语句可以单行或多行书写，以分号结尾。</p></li><li><p>可使用空格和缩进来增强语句的可读性。</p></li><li><p>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</p></li><li><p>3 种注释</p><ul><li>单行注释: – 注释内容（注意–后面的空格） 或 # 注释内容(mysql 特有) </li><li>多行注释: /* 注释 */（与java多行注释相似）</li></ul></li></ol><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>DDL(Data Definition Language)数据定义语言<pre><code> 用来定义数据库对象：**数据库，表，列**等。关键字：create, drop,alter 等</code></pre></li><li>DML(Data Manipulation Language)数据操作语言<pre><code> 用来对数据库中表的**数据**进行**增删改**。关键字：insert, delete, update 等</code></pre></li><li>DQL(Data Query Language)数据查询语言<pre><code> 用来**查询**数据库中表的**记录(数据)**。关键字：select, where 等</code></pre></li><li>DCL(Data Control Language)数据控制语言(了解)<pre><code> 用来定义数据库的**访问权限和安全级别，及创建用户**。关键字：GRANT， REVOKE 等</code></pre></li></ol><h1 id="DDL：操作数据库、表"><a href="#DDL：操作数据库、表" class="headerlink" title="DDL：操作数据库、表"></a>DDL：操作数据库、表</h1><h2 id="操作数据库："><a href="#操作数据库：" class="headerlink" title="操作数据库："></a>操作数据库：</h2><h3 id="CRUD语句"><a href="#CRUD语句" class="headerlink" title="CRUD语句"></a>CRUD语句</h3><p>CRUD定义：</p><ul><li>C(Create):创建</li><li>R(Retrieve)：查询</li><li>U(Update):修改</li><li>D(Delete):删除</li></ul><hr><h4 id="Create语句："><a href="#Create语句：" class="headerlink" title="Create语句："></a>Create语句：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名;    -- 创建数据库</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922003534168.png" alt="image-20200922003534168"></p><p>新创建的数据库与已知数据库重名时：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922003651221.png" alt="image-20200922003651221"></p><p>可以使用以下语句避免错误出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database if not exists  数据库名;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922004033053.png" alt="image-20200922004033053"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922004149497.png" alt="image-20200922004149497"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名 character set 字符集名称;    -- 创建数据库并指定字符集</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922004608579.png" alt="image-20200922004608579"></p><p>创建数据库db4，判断是否重名，并指定字符集为gbk:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database if not exists db4 character set gbk;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922004943303.png" alt="image-20200922004943303"></p><h4 id="Retrieve语句："><a href="#Retrieve语句：" class="headerlink" title="Retrieve语句："></a>Retrieve语句：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;     -- 查询所有已创建的数据库</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922001542219.png" alt="image-20200922001542219"></p><blockquote><p>在MySQL数据库的数据目录下（win7：<code>C:\ProgramData\MySQL\MySQL Server 5.5\data</code>）有三个文件夹，就是MySQL自带的数据库。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922001933690.png" alt="image-20200922001933690"></p><p>**<code>information_schema</code>**：视图，并不是真正的数据库。它提供了访问数据库元数据的方式。没有在data目录下。</p><p><strong><code>mysql库</code>**：这个是mysql的核心数据库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。</strong>不可以删除**。</p><p><strong><code>performance_schema</code>**：对性能提升进行操作的数据库。</strong>尽量别动**</p><p><strong><code>test</code></strong>:测试数据库。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create database 数据库名;    -- 查看某个数据库字符集的名称（安装时默认utf-8)、查看某个数据库的创建语句</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922003250158.png" alt="image-20200922003250158"></p><h4 id="Update语句："><a href="#Update语句：" class="headerlink" title="Update语句："></a>Update语句：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database 数据库名 character set 字符集;    -- 更改指定数据库的字符集</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922005857294.png" alt="image-20200922005857294"></p><h4 id="Delete语句："><a href="#Delete语句：" class="headerlink" title="Delete语句："></a>Delete语句：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database 数据库名;    -- 删除指定数据库，删除不存在的数据库会报错</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922010138546.png" alt="image-20200922010138546"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists 数据库名;    -- 如果存在则删除</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922010340797.png" alt="image-20200922010340797"></p><h3 id="使用数据库的语句"><a href="#使用数据库的语句" class="headerlink" title="使用数据库的语句"></a>使用数据库的语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();     -- 查询当前使用的数据库</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922010702349.png" alt="image-20200922010702349"></p><p>返回NULL，当前未使用任何数据库；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名称;    -- 使用指定数据库</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922010821110.png" alt="image-20200922010821110"></p><h2 id="操作数据库的表："><a href="#操作数据库的表：" class="headerlink" title="操作数据库的表："></a>操作数据库的表：</h2><h3 id="Create："><a href="#Create：" class="headerlink" title="Create："></a>Create：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create 表名(</span><br><span class="line">列名1 数据类型1,</span><br><span class="line">列名2 数据类型2,</span><br><span class="line">...</span><br><span class="line">列名n 数据类型n</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><h4 id="MySQL常见数据类型："><a href="#MySQL常见数据类型：" class="headerlink" title="MySQL常见数据类型："></a>MySQL常见数据类型：</h4><ul><li>int：整数类型    <code>age int,</code></li><li>double:小数类型   <code>score  double(int digits1，int digits2),</code>digits1：位数，digits2：保留小数点后位数</li><li>date:日期，只包含年月日，格式：<code>yyyy-MM-dd</code></li><li>datetime:日期，包含年月日时分秒，格式：<code>yyyy-MM-dd HH:mm:ss</code></li><li>timestamp:时间戳日期，包含年月日时分秒，不赋值或赋值为NULL时，自动为其赋值为当前系统时间。</li><li>varchar:字符串，<code>name varchar(int length)</code>length:最多能容纳的字符数。name  varchar(20)名字最多容纳20个字符张三：两个字符——zhangsan：八个字符</li></ul></blockquote><p>在数据库db1中创建一个学生表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table Student(</span><br><span class="line">id int, -- 编号</span><br><span class="line">name varchar(20), -- 名字</span><br><span class="line">age int,  -- 年龄</span><br><span class="line">birthday date,   -- 出生日期</span><br><span class="line">score double(4,1),   -- 分数</span><br><span class="line">createTime timestamp  -- 创建时间</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​        <img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922022121545.png" alt="image-20200922022121545"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922022147065.png" alt="image-20200922022147065"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 新的表名 like 已存在的表名;  -- 复制表</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922022528398.png" alt="image-20200922022528398"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922022609381.png" alt="image-20200922022609381"></p><h3 id="Retrieve："><a href="#Retrieve：" class="headerlink" title="Retrieve："></a>Retrieve：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;    -- 查询正在使用的数据库中的所有表</span><br></pre></td></tr></table></figure><p>用use命令切换到mysql：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922011712171.png" alt="image-20200922011712171"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名称;   -- desc:description ,查询表结构</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922011913444.png" alt="image-20200922011913444"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名;   -- 展示表的字符集</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922023238467.png" alt="image-20200922023238467"></p><h3 id="Update："><a href="#Update：" class="headerlink" title="Update："></a>Update：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 rename to 新的表名;    -- 修改表名</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922023028607.png" alt="image-20200922023028607"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 character set 字符集名;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922023457614.png" alt="image-20200922023457614"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 列名 数据类型;  -- 给表添加一列</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922023844489.png" alt="image-20200922023844489"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change 列名 新的列名 新的数据类型; -- 修改表的列名及数据类型</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922024110363.png" alt="image-20200922024110363"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 列名 新数据类型;  -- 修改列的数据类型</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922024259774.png" alt="image-20200922024259774"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 列名;   -- 删除列</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922024440724.png" alt="image-20200922024440724"></p><h3 id="Delete："><a href="#Delete：" class="headerlink" title="Delete："></a>Delete：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists 表名;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922022657901.png" alt="image-20200922022657901"></p><h1 id="DML-操作数据库中表的记录"><a href="#DML-操作数据库中表的记录" class="headerlink" title="DML:操作数据库中表的记录"></a>DML:操作数据库中表的记录</h1><p>重点掌握。包括添加数据，删除数据，修改数据。</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(列名1,列名2,...,列名n) values(值1,值2,...,值n);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922160000237.png" alt="image-20200922160000237"></p><p>查询表中记录(DQL语句):</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922160545422.png" alt="image-20200922160545422"></p><p>注意事项：</p><p>1、列名和值要一 一对应（数据类型和个数都要一致）；</p><p>2、如果表名后不定义列名，则默认给所有列添加值（不想添加值的value可以用NULL表示）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values(值1,值2,...,值n);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922161232693.png" alt="image-20200922161232693"></p><p>3、除了数字，其他类型都需要用引号（单双引号皆可）括起来。</p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete form 表名 [where 条件];    -- []中是可选的</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922162308779.png" alt="image-20200922162308779"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922162401069.png" alt="image-20200922162401069"></p><p>不加条件时，默认删除表中所有记录。不推荐使用，因为表中有多少条记录，就会执行多少次删除操作，效率较低。</p><p>推荐使用以下语句，删除全部记录，效率比较高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table 表名;    -- 先删除表，再创建一个一模一样的表</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922162737278.png" alt="image-20200922162737278"></p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 列名1&#x3D;值1,列名2&#x3D;值2,...[where 条件];</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922164110490.png" alt="image-20200922164110490"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922164237142.png" alt="image-20200922164237142"></p><p>如果不加任何条件，则会将表中所有记录全部修改。</p><h1 id="DQL：数据查询"><a href="#DQL：数据查询" class="headerlink" title="DQL：数据查询"></a>DQL：数据查询</h1><p>最重要的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">字段列表</span><br><span class="line">from</span><br><span class="line">表名列表</span><br><span class="line">where</span><br><span class="line">条件列表</span><br><span class="line">group by</span><br><span class="line">分组字段</span><br><span class="line">having</span><br><span class="line">分组之后的条件</span><br><span class="line">order by</span><br><span class="line">按【】排序</span><br><span class="line">limit</span><br><span class="line">分页限定</span><br></pre></td></tr></table></figure><h2 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名;  -- 查询表中所有记录</span><br></pre></td></tr></table></figure><h3 id="多字段查询"><a href="#多字段查询" class="headerlink" title="多字段查询"></a>多字段查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 列名1,列名2,... from 表名; -- 多字段查询</span><br></pre></td></tr></table></figure><h4 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4><p>1.创建一个表student：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student( </span><br><span class="line">id int, -- 编号 </span><br><span class="line">name varchar(20), -- 姓名 </span><br><span class="line">age int, -- 年龄 </span><br><span class="line">sex varchar(5), -- 性别 </span><br><span class="line">address varchar(100), -- 地址 </span><br><span class="line">math int, -- 数学 </span><br><span class="line">english int -- 英语 </span><br><span class="line">); </span><br><span class="line">INSERT INTO </span><br><span class="line">student(id,NAME,age,sex,address,math,english) </span><br><span class="line">VALUES </span><br><span class="line">(1,&#39;马云&#39;,55,&#39;男&#39;,&#39;杭州&#39;,66,78),</span><br><span class="line">(2,&#39;马化腾&#39;,45,&#39;女&#39;,&#39;深圳&#39;,98,87),</span><br><span class="line">(3,&#39;马景涛&#39;,55,&#39;男&#39;,&#39;香港&#39;,56,77),</span><br><span class="line">(4,&#39;柳岩&#39;,20,&#39;女&#39;,&#39;湖南&#39;,76,65),</span><br><span class="line">(5,&#39;柳青&#39;,20,&#39;男&#39;,&#39;湖南&#39;,86,NULL),</span><br><span class="line">(6,&#39;刘德华&#39;,57,&#39;男&#39;,&#39;香港&#39;,99,99),</span><br><span class="line">(7,&#39;马德&#39;,22,&#39;女&#39;,&#39;香港&#39;,99,99),</span><br><span class="line">(8,&#39;德玛西亚&#39;,18,&#39;男&#39;,&#39;南京&#39;,56,65);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922173407504.png" alt="image-20200922173407504"></p><p>2.从student表中查询姓名，math，和English</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,math,english from student;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922173618963.png" alt="image-20200922173618963"></p><h3 id="去重查询"><a href="#去重查询" class="headerlink" title="去重查询"></a>去重查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select address from student;</span><br></pre></td></tr></table></figure><p>使用该语句查询时，会出现重复的项目：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922173926807.png" alt="image-20200922173926807"></p><p>可以使用关键字 <code>distinct</code>去重查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct address from student;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922174106138.png" alt="image-20200922174106138"></p><p>只有查询出的结果完全一致时才会去重，比如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct name,address from student;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922174229579.png" alt="image-20200922174229579"></p><p>因为姓名有一致的，即使地址重复了，且使用了地distinct关键字也不会将重复地址筛选掉。</p><h3 id="计算列"><a href="#计算列" class="headerlink" title="计算列"></a>计算列</h3><p> 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</p><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,math,english,math+english from student; -- 查询名字，数学成绩，英语成绩并计算总成绩</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922174559726.png" alt="image-20200922174559726"></p><h4 id="ifnull-exp1-exp2-函数"><a href="#ifnull-exp1-exp2-函数" class="headerlink" title="ifnull(exp1,exp2)函数"></a>ifnull(exp1,exp2)函数</h4><p>从上述操作中可以发现，当查询的值中存在NULL时，进行四则运算后得到的值也会是NULL。为了避免出现这种问题，我们可以使用<code>ifnull</code>函数来进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifnull(exp1,exp2)   -- exp1表示可能为null的值，exp2表示将NULL替换掉的值</span><br></pre></td></tr></table></figure><p>因此上述计算总分的查询语句可以改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,math,english,math+ifnull(english,0) from student; -- 为NULL时就将值用0替换</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922175500877.png" alt="image-20200922175500877"></p><h3 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h3><p>从上述查询我们发现列<code>math+ifnull(english,0)</code>在结果中不好看，所以我们可以对其设置别名，当然任意列都可以设置别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名 as 别名 -- 使用关键字as对列名设置别名</span><br></pre></td></tr></table></figure><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,math,english,math+ifnull(english,0) as 总分 from student;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922180001216.png" alt="image-20200922180001216"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name as 姓名,math as 数学,english as 英语,math+ifnull(english,0) as 总分 from student;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922180146752.png" alt="image-20200922180146752"></p><h4 id="起别名简化形式"><a href="#起别名简化形式" class="headerlink" title="起别名简化形式"></a>起别名简化形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 列名1 别名1,列名2 别名2,... from 表名;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,math 数学,english 英语,math+ifnull(english,0) 总分 from student;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922180414253.png" alt="image-20200922180414253"></p><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>where子句后加条件。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th>比较运算符</th><th>备注</th></tr></thead><tbody><tr><td>&gt;、&lt;、=、&gt;=、&lt;=、&lt;&gt;</td><td>&lt;&gt;在SQL中表示不等于，在mysql中也可以使用!=没有==</td></tr><tr><td>BETWEEN…AND…</td><td>在一个范围之内，包头又包尾</td></tr><tr><td>IN(集合)</td><td>集合表示多个值，各个值之间用逗号隔开</td></tr><tr><td>LIKE ‘张%’</td><td>模糊查询</td></tr><tr><td>IS [NOT] NULL</td><td>查询某一列为[NOT]NULL的值，注：不能写=NULL(!=NULL)</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>备注</th></tr></thead><tbody><tr><td>&amp;&amp;或 AND</td><td>与，SQL中建议使用AND，&amp;&amp;并不通用。</td></tr><tr><td>|| 或 OR</td><td>或，SQL中建议使用OR，||并不通用。</td></tr><tr><td>! 或 NOT</td><td>非，SQL中建议使用NOT，!并不通用。</td></tr></tbody></table><h3 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h3><p>1.查询math大于80的人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where math &gt; 80;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922222724078.png" alt="image-20200922222724078"></p><p>查询English小于90的人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where english &lt; 90;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922222757117.png" alt="image-20200922222757117"></p><p>查询sex等于女的人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where sex &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922222936439.png" alt="image-20200922222936439"></p><p>2、查询年龄位于18-30（包含两头）之间的人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 以下查询效果一致</span><br><span class="line">select * from student where age &gt;&#x3D; 18 &amp;&amp; age &lt;&#x3D; 30;</span><br><span class="line">select * from student where age &gt;&#x3D; 18 AND age &lt;&#x3D; 30; -- 推荐使用AND,不推荐&amp;&amp;</span><br><span class="line">select * from student where age BETWEEN 18 AND 30;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922223444233.png" alt="image-20200922223444233"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922223514518.png" alt="image-20200922223514518"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922223625776.png" alt="image-20200922223625776"></p><p>3.查询英语成绩为空的人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where english IS NULL;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922223931763.png" alt="image-20200922223931763"></p><p>4.查询英语成绩不为空的人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where english IS NOT NULL;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922224126958.png" alt="image-20200922224126958"></p><p>5.查询年龄为18，22，50的人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 以下查询结果一致</span><br><span class="line">select * from student where age IN(18,22,50);</span><br><span class="line">select * from student where age &#x3D; 18 OR age &#x3D; 22 OR age &#x3D; 50;-- 推荐使用OR，不推荐||</span><br><span class="line">select * from student where age &#x3D; 18 || age &#x3D; 22 || age &#x3D; 50;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922224250640.png" alt="image-20200922224250640"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922224557584.png" alt="image-20200922224557584"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922224637532.png" alt="image-20200922224637532"></p><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>MySQL通配符：_:匹配单个任意字符；%:匹配任意多个字符。</p><p>查询姓马的有哪些人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where name LIKE &#39;马%&#39;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922230728661.png" alt="image-20200922230728661"></p><p>查询姓名第二个字为化的人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where name LIKE &#39;_化%&#39;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922230954627.png" alt="image-20200922230954627"></p><p>查询名字包含德字的人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where name LIKE &#39;%德%&#39;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922231144759.png" alt="image-20200922231144759"></p><p>查询名字是三个字的人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where name LIKE &#39;___&#39;;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200922231318145.png" alt="image-20200922231318145"></p><h1 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h1><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>涉及多张表的操作。</p><p>数据有冗余的时候，进行表的拆分，然后利用外键对拆分的表进行关联。</p><h3 id="添加外键"><a href="#添加外键" class="headerlink" title="添加外键"></a>添加外键</h3><p>1.在创建表时添加外键约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">...</span><br><span class="line">    外键列：外键列名称 数据类型,</span><br><span class="line">    constraint 外键名称 foreign key (外键列名称) references 主键表名(主键列名称),</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中，外键名称可以任意取，主键表名，即为关联的表名。</p><p>2.在表创建完成之后添加外键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add constraint 外键名 foreign key(外键列名) references 主表名(主键列名);</span><br></pre></td></tr></table></figure><h4 id="代码演示-3"><a href="#代码演示-3" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个部门表，作为主表，因为副表需要引用他，所以需要先创建</span><br><span class="line">CREATE TABLE department(</span><br><span class="line">dep_id INT INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">dep VARCHAR(20),</span><br><span class="line">dep_loacation VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">-- 向表中添加两个部门</span><br><span class="line">INSERT INTO department VALUES(NULL, &#39;研发部&#39;,&#39;广州&#39;),(NULL, &#39;销售部&#39;, &#39;深圳&#39;);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200926164650983.png" alt="image-20200926164650983"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 创建员工表，利用外键和部门表产生关联</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(20),</span><br><span class="line">age INT,</span><br><span class="line">dep_id INT,  -- 外键列，与主表主键列类型要一致</span><br><span class="line">CONSTRAINT emp_dep_id FOREIGN KEY(dep_id) REFERENCES department(dep_id)</span><br><span class="line">);</span><br><span class="line">-- 添加员工信息</span><br><span class="line">INSERT INTO employee (NAME, age, dep_id) VALUES </span><br><span class="line">(&#39;张三&#39;, 20, 1),</span><br><span class="line">(&#39;李四&#39;, 21, 1),</span><br><span class="line">(&#39;王五&#39;, 20, 1),</span><br><span class="line">(&#39;老王&#39;, 20, 2),</span><br><span class="line">(&#39;大王&#39;, 22, 2),</span><br><span class="line">(&#39;小王&#39;, 18, 2);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200926165713224.png" alt="image-20200926165713224"></p><p>添加约束后，主键的列不能被删除，因为和从表产生了关联</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/bu2cheng/picpic@master/blogimg/image-20200926165821510.png" alt="image-20200926165821510"></p><h3 id="删除外键"><a href="#删除外键" class="headerlink" title="删除外键"></a>删除外键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop foreign key 外键名称;</span><br></pre></td></tr></table></figure><h2 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h2><p>添加级联操作时需要谨慎对待。在添加外键约束的语句中添加相应的语法，以便主表改变时，从表发生相应变化。级联操作有两种：级联更新和级联删除。级联更新：主表的主键发生变化时，从表的外键也会发生相应变化。级联删除：主表删除主键列的数据时，相应的从表的外键列会被全部删除。因此添加级联操作时要慎之又慎。</p><h3 id="级联更新"><a href="#级联更新" class="headerlink" title="级联更新"></a>级联更新</h3><p>在添加外键约束的语句中添加相应的语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on update cascade</span><br></pre></td></tr></table></figure><p>1.创建表时添加级联更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">...</span><br><span class="line">    外键列：外键列名 数据类型,</span><br><span class="line">    constraint 外键名称 foreign key(外键列名) references 主表名(主键名) on update cascade,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2.创建完表后添加级联更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add constraint 外键名称 foreign key(外键列名) refereces 主表名(主键列名) on update cascade;</span><br></pre></td></tr></table></figure><p>3.删除级联更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop foreign key  外键名称;</span><br></pre></td></tr></table></figure><h3 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on delete cascade</span><br></pre></td></tr></table></figure><p>1.创建表时添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">...</span><br><span class="line">    外键列：外键列名 数据类型,</span><br><span class="line">    constraint 外键名称 foreign key(外键列名) references 主表名(主键名) on delete cascade,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2.创建完表后添加级联更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add constraint 外键名称 foreign key(外键列名) refereces 主表名(主键列名) on delete cascade;</span><br></pre></td></tr></table></figure><p>3.删除级联更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop foreign key  外键名称;</span><br></pre></td></tr></table></figure><h3 id="同时添加两种级联操作"><a href="#同时添加两种级联操作" class="headerlink" title="同时添加两种级联操作"></a>同时添加两种级联操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">...</span><br><span class="line">    外键列：外键列名 数据类型,</span><br><span class="line">    constraint 外键名称 foreign key(外键列名) references 主表名(主键名)on update cascade on delete cascade,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 笔记 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于github图床搭建问题</title>
      <link href="posts/1800832272/"/>
      <url>posts/1800832272/</url>
      
        <content type="html"><![CDATA[<p>按照网上的教程，使用github+PicGo+jsDelivr的方式搭建免费图床，配置如下，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/%E5%85%B3%E4%BA%8Egithub%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%981.png"></p><p>一直显示服务端出错，请重试。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/%E5%85%B3%E4%BA%8Egithub%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%982.png" alt="image-20201008184820098"></p><p>按照网上的教程，改了又改，怎么都不能上传成功。最后去github看，主分支变成了<code>main</code>，而不再是<code>master</code>。于是把配置中的分支改为了<code>main</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/%E5%85%B3%E4%BA%8Egithub%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%983.png"></p><p>测试了一下，上传成功！</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/%E5%85%B3%E4%BA%8Egithub%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%984.png" alt="image-20201008190221582"></p><p>查了一下原因，原来是BLM的原因，说来实在可笑！</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@main/%E5%85%B3%E4%BA%8Egithub%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%985.png"></p><p>这个问题解决了，新的问题随之产生了！发现从picgo自动生成的链接导入typora后，图片加载不出来。直接使用浏览器访问时，出现如下问题：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@main/%E5%85%B3%E4%BA%8Egithub%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%986.png"></p><p>上网查了一下，是github的问题，时墙时不墙。没有什么特别好的方法。所以暂时也只能把图片都同步到vercel了。</p><p><strong>已解决！</strong></p><p>还是<code>master</code>的问题。将自定义域名改为<code>https://cdn.jsdelivr.net/gh/zerohk/blogpic@main</code>的形式即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/%E5%85%B3%E4%BA%8Egithub%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%987.png"></p><p>相册区能正确显示，浏览器也能正确显示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/fkso/blogpics/raw/master/master/%E5%85%B3%E4%BA%8Egithub%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%988.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zerohk/blogpic@main/%E5%85%B3%E4%BA%8Egithub%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%989.png"></p><p>但是github还是时好时坏，无法解决。</p><hr><p>10-12再次更新。</p><p>发现有时候不是网络原因，可能是账号原因，换个账号，换个token又能继续上传了。总之，还是不要滥用为好，毕竟是白嫖。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布文章指南</title>
      <link href="posts/1820155650/"/>
      <url>posts/1820155650/</url>
      
        <content type="html"><![CDATA[<h1 id="一、创建新的页面和文章"><a href="#一、创建新的页面和文章" class="headerlink" title="一、创建新的页面和文章"></a>一、创建新的页面和文章</h1><p>使用默认hexo命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建新页面</span></span><br><span class="line">hexo new page pagename </span><br><span class="line"><span class="meta">#</span><span class="bash"> 简化命令</span></span><br><span class="line">hexo n page pagename</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建新文章</span></span><br><span class="line">hexo new post postname</span><br><span class="line"><span class="meta">#</span><span class="bash"> 简化命令</span></span><br><span class="line">hexo n post postname</span><br></pre></td></tr></table></figure><p>由于butterfly主题的一些特性，所以更改了<code>./scaffolds</code>目录下的<code>page.md</code>和<code>post.md</code>，使得其在生成页面或文章的时候，会自动生成主题可能需要的<code>Front-matter</code></p><blockquote><p>Front-matter 是文档最上方以 — 分隔的区域，用于指定各种参数。</p></blockquote><p>下面分别是page页和post页的Front-matter的参数和各参数的用法。</p><h2 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h2><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="参数用法"><a href="#参数用法" class="headerlink" title="参数用法"></a>参数用法</h3><table><thead><tr><th>参数</th><th>用途</th></tr></thead><tbody><tr><td>title</td><td>【必需】頁面標題</td></tr><tr><td>date</td><td>【必需】頁面創建日期</td></tr><tr><td>type</td><td>【必需】標籤、分類和友情鏈接三個頁面需要配置</td></tr><tr><td>updated</td><td>【可選】頁面更新日期</td></tr><tr><td>description</td><td>【可選】頁面描述</td></tr><tr><td>keywords</td><td>【可選】頁面關鍵字</td></tr><tr><td>comments</td><td>【可選】顯示頁面評論模塊(默認 true)</td></tr><tr><td>top_img</td><td>【可選】頁面頂部圖片，可输入url地址，也可以设置为false，不显示顶图</td></tr><tr><td>mathjax</td><td>【可選】顯示mathjax(當設置mathjax的per_page: false時，才需要配置，默認 false)（暂未安装）</td></tr><tr><td>katex</td><td>【可選】顯示katex(當設置katex的per_page: false時，才需要配置，默認 false)（暂未安装）</td></tr><tr><td>aside</td><td>【可選】顯示側邊欄 (默認 true)</td></tr><tr><td>aplayer</td><td>【可選】在需要的頁面加載aplayer的js和css（暂未配置）</td></tr><tr><td>highlight_shrink</td><td>【可選】配置代碼框是否展開(true/false)(默認為設置中highlight_shrink的配置)</td></tr></tbody></table><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>如果没有特殊需求，除了必选项，其余各项缺省即可</p><h2 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h2><h3 id="参数列表-1"><a href="#参数列表-1" class="headerlink" title="参数列表"></a>参数列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">updated:</span><br><span class="line">sticky:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">password: </span><br><span class="line">abstract: </span><br><span class="line">message: .</span><br><span class="line">wrong<span class="emphasis">_pass_</span>message: </span><br><span class="line">wrong<span class="emphasis">_hash_</span>message: </span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">auto<span class="emphasis">_open:</span></span><br><span class="line"><span class="emphasis">copyright:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author:</span><br><span class="line">copyright<span class="emphasis">_author_</span>href:</span><br><span class="line">copyright<span class="emphasis">_url:</span></span><br><span class="line"><span class="emphasis">copyright_</span>info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight<span class="emphasis">_shrink:</span></span><br></pre></td></tr></table></figure><h3 id="参数用法-1"><a href="#参数用法-1" class="headerlink" title="参数用法"></a>参数用法</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><table><thead><tr><th>参数</th><th>用途</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章標題</td></tr><tr><td>date</td><td>【必需】文章創建日期</td></tr><tr><td>updated</td><td>【可選】文章更新日期</td></tr><tr><td>sticky</td><td>【可选】文章置顶，数字越大，优先级越高</td></tr><tr><td>tags</td><td>【可选】文章标签</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>password</td><td>【可选】给博客加密，在此处输入密码即可</td></tr><tr><td>abstract:</td><td>【可选】未知</td></tr><tr><td>message</td><td>【可選】加密文章提示</td></tr><tr><td>wrong_pass_message</td><td>【可选】加密文章密码错误提示</td></tr><tr><td>wrong_hash_message</td><td>【可选】未知</td></tr><tr><td>keywords</td><td>【可選】文章關鍵字</td></tr><tr><td>description</td><td>【可選】文章描述</td></tr><tr><td>comments</td><td>【可選】顯示文章評論模塊(默認 true)</td></tr><tr><td>top_img</td><td>【可選】文章頂部圖片</td></tr><tr><td>cover</td><td>【可选】文章縮略圖(如果沒有設置top_img,文章頁頂部將顯示縮略圖，可設為false/圖片地址/留空)</td></tr><tr><td>toc</td><td>【可選】顯示文章TOC(默認為設置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可選】顯示toc_number(默認為設置中toc的number配置)</td></tr><tr><td>auto_open</td><td>【可選】是否自動打開TOC(默認為設置中toc的auto_open配置)</td></tr><tr><td>copyright</td><td>【可選】顯示文章版權模塊(默認為設置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可選】文章版權模塊的<strong>文章作者</strong></td></tr><tr><td>copyright_author_href</td><td>【可選】文章版權模塊的<strong>文章作者</strong>鏈接</td></tr><tr><td>copyright_url</td><td>【可選】文章版權模塊的<strong>文章連結</strong>鏈接</td></tr><tr><td>copyright_info</td><td>【可選】文章版權模塊的<strong>版權聲明</strong>文字</td></tr><tr><td>mathjax</td><td>【可選】顯示mathjax(當設置mathjax的per_page: false時，才需要配置，默認 false)（暂未安装）</td></tr><tr><td>katex</td><td>【可選】顯示katex(當設置katex的per_page: false時，才需要配置，默認 false)（暂未安装）</td></tr><tr><td>aplayer</td><td>【可選】在需要的頁面加載aplayer的js和css（暂未配置）</td></tr><tr><td>highlight_shrink</td><td>【可選】配置代碼框是否展開(true/false)(默認為設置中highlight_shrink的配置)</td></tr></tbody></table><h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h3><p>如果没有特殊需求，除了必选项，其余各项缺省即可。</p><h1 id="二、更新站点"><a href="#二、更新站点" class="headerlink" title="二、更新站点"></a>二、更新站点</h1><p>由于安装了<code>hexo-douban</code>和<code>hexo-calendar</code>两个插件，和默认命令有冲突，所以文章写好后，不能使用简化命令直接对站点进行更新，需要采用以下命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">清空缓存，删除pulic目录</span></span><br><span class="line">hexo clean </span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成静态文件，生成public目录</span></span><br><span class="line">hexo generate</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不可直接用hexo g来生成静态文件，但可以使用以下简化命令</span></span><br><span class="line">hexo ge</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部署网站</span></span><br><span class="line">hexo deploy</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不可直接用hexo d来部署，但可以使用一下简化命令</span></span><br><span class="line">hexo de</span><br></pre></td></tr></table></figure><p>可选命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Usage: hexo generate</span><br><span class="line">Description:</span><br><span class="line">Generate static files.</span><br><span class="line">Options:</span><br><span class="line">  -b, --bail         Raise an error if any unhandled exception is thrown during generation</span><br><span class="line">  -c, --concurrency  Maximum number of files to be generated in parallel. Default is infinity</span><br><span class="line">  -d, --deploy       Deploy after generated,生成后直接部署</span><br><span class="line">  -f, --force        Force regenerate</span><br><span class="line">  -w, --watch        Watch file changes，只生成发生改变的页面</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在执行hexo generate之后，可以使用该命令更新豆瓣数据，默认会生成books,game,movies页面</span></span><br><span class="line">hexo douban</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Usage: hexo douban</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Description:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Generate pages from douban</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Options:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -b, --books   Generate douban books only</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -g, --games   Generate douban games only</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  -m, --movies  Generate douban movies only</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">########因为只有books和movies进行了标记只需要执行以下命令即可</span></span></span><br><span class="line">  hexo douban -bm</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在执行hexo generate之后，可以使用该命令更新关于页面网站活动数据</span></span><br><span class="line">hexo gc -w=40</span><br><span class="line"><span class="meta">#</span><span class="bash">Usage: hexo gc</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Generate calendar.json</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
